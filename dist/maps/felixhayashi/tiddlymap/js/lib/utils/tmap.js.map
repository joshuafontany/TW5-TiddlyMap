{"version":3,"sources":["felixhayashi/tiddlymap/js/lib/utils/tmap.js"],"names":["Object","defineProperty","exports","value","getSnapshotTitle","getArrayValuesAsHashmapKeys","getLookupTable","keyOfItemWithProperty","keysOfItemsWithProperty","getDublicates","getId","refreshDataSet","drawRaster","getPrettyFilter","groupByProperty","isEdgeTypeMatch","getEdgeTypeMatches","getDataUri","convert","getValues","getIterableCollection","getLabel","undefined","_typeof","Symbol","iterator","obj","constructor","prototype","_vis","require","_vis2","_interopRequireDefault","_exception","_basic","basicUtils","_interopRequireWildcard","_wiki","wikiUtils","__esModule","newObj","key","hasOwnProperty","call","default","tiddler","aliasField","tObj","getTiddler","fields","title","replace","col","vis","DataSet","get","Array","isArray","returnType","result","keys","i","length","push","outputType","InvalidArgumentException","mapper","array","hashmap","dataset","type","isForceBase64","imgTObj","body","text","encoding","$tw","config","contentTypeInfo","hasSubString","base64","eTyFiltAutoPrefix","filter","arguments","titles","getTiddlersByPrefix","$tm","path","edgeTypes","removePrefix","getMatches","isMatch","prop","makeHashMap","item","val","expr","trim","re","operands","match","stringsPlusDummies","split","operandIndex","parts","l","join","ctx","scaleFactor","viewCenter","rasterSize","color","_basicUtils$getNeares","getNearestRasterPosition","centerX","x","centerY","y","scaledWidth","canvas","width","scaledHeight","height","extraLines","hSpace","Math","ceil","vSpace","left","right","top","bottom","beginPath","moveTo","lineTo","strokeStyle","fillStyle","stroke","ds","ltNew","ltOld","inserted","updated","withoutPosition","removed","id","isEqual","remove","add","tiddlers","getTiddlersWithField","limit","getTiddlerRef","index","lookupKey","lookupTable","idx","Error","viewLabel","Date","toDateString"],"mappings":"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","file":"../../../../../../felixhayashi/tiddlymap/js/lib/utils/tmap.js","sourcesContent":["/* @preserve TW-Guard */\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/lib/utils/tmap\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n/* @preserve TW-Guard */\n\n/*** Imports *******************************************************/\n\nimport vis                  from '$:/plugins/felixhayashi/vis/vis.js';\nimport {\n  EnvironmentError,\n  InvalidArgumentException,\n}                           from '$:/plugins/felixhayashi/tiddlymap/js/exception';\nimport * as basicUtils      from '$:/plugins/felixhayashi/tiddlymap/js/lib/utils/basic';\nimport * as wikiUtils       from '$:/plugins/felixhayashi/tiddlymap/js/lib/utils/wiki';\n\n/**\n * TODO: this method does not seem to be used!\n * @param {Tiddler} tiddler\n * @param {string} aliasField - A tiddler field that contains an\n *     alternative title (e.g. \"caption\").\n * @return {string|undefined} If the `aliasField` exists and is not\n *     empty, the value of the `aliasField` otherwise the tiddler's\n *     title or undefined if the tiddler doesn't exist.\n */\nexport const getLabel = (tiddler, aliasField) => {\n  const tObj = wikiUtils.getTiddler(tiddler);\n  return (\n    tObj &&\n    tObj.fields[aliasField]\n      ? tObj.fields[aliasField]\n      : tObj.fields.title\n  ).replace('\\\\n', '\\n');\n};\n\n/**\n * This function will return a collection object whose data can be\n * via `Object.keys(col)` in a loop.\n *\n * @param {Collection} col - A collection\n * @return {Hashmap} The iterable object.\n */\nexport const getIterableCollection = col => col instanceof vis.DataSet ? col.get() : col;\n\n/**\n * Extract all the values from a collection. If `col` is an object,\n * only properties are considered that are its own and iterable.\n *\n * @param {Collection} col\n * @return {Array} An array\n */\nexport const getValues = col => {\n\n  if (Array.isArray(col)) {\n\n    return col; // bounce back.\n\n  } else if (col instanceof vis.DataSet) { // a dataset\n\n    return col.get({ returnType: 'Array' });\n\n  }\n\n  const result = [];\n  const keys = Object.keys(col);\n  for (let i = keys.length; i--;) {\n    result.push(col[keys[i]]);\n  }\n\n  return result;\n\n};\n\n/**\n * Transforms a collection of a certain type into a collection of\n * another type.\n *\n * **Attention**: When trying to convert an array into a object, the\n * array will be simply bounced back. Let's hope no one added enumerable\n * properties to Array.prototype :)\n *\n * @param {Collection} col - The collection to convert.\n * @param {CollectionTypeString} [outputType=\"dataset\"] - The output type.\n * @return {Collection} A **new** collection of type `outputType`.\n */\nexport const convert = (col, outputType) => {\n\n  if (typeof col !== 'object') {\n    throw new InvalidArgumentException(col, outputType);\n  }\n\n  if (outputType === 'object') {\n    outputType = 'hashmap';\n  }\n\n  const mapper = {\n    array: col => getValues(col),\n    hashmap: col =>\n      col instanceof vis.DataSet ? col.get({ returnType: 'Object' }) : col,\n    dataset: col =>\n      col instanceof vis.DataSet ? col : (!Array.isArray(col) ? getValues(col) : new vis.DataSet(col))\n  };\n\n  return mapper[outputType](col);\n\n};\n\n/**\n * @param {Tiddler} tiddler\n * @param {string} [type]\n * @param {boolean} [isForceBase64]\n * @return {string}\n */\nexport const getDataUri = (tiddler, type, isForceBase64) => {\n\n  const imgTObj = wikiUtils.getTiddler(tiddler);\n  type = type || imgTObj.fields.type || 'image/svg+xml';\n  let body = imgTObj.fields.text;\n  let encoding = $tw.config.contentTypeInfo[type].encoding;\n\n  if (type === 'image/svg+xml') {\n\n    // see http://stackoverflow.com/questions/10768451/inline-svg-in-css\n    body = body.replace(/\\r?\\n|\\r/g, ' ');\n\n    if (!basicUtils.hasSubString('xmlns', body)) {\n      // @tiddlywiki it is bad to remove the xmlns attribute!\n\n      body = body.replace(/<svg/, '<svg xmlns=\"http://www.w3.org/2000/svg\"');\n    }\n\n  }\n\n  if (isForceBase64 && encoding !== 'base64') {\n    encoding = 'base64';\n    body = basicUtils.base64(body);\n  }\n\n  return `data:${type};${encoding},${body}`;\n\n};\n\n// @todo move this to environment\nconst eTyFiltAutoPrefix = '[all[]] ';\n\n/**\n *\n * @param filter\n * @param titles\n * @return {*}\n */\nexport const getEdgeTypeMatches = (filter = '', titles) => {\n\n  if (!titles) {\n    titles = wikiUtils.getTiddlersByPrefix(`${$tm.path.edgeTypes}/`, {\n      iterator: 'eachTiddlerPlusShadows',\n      removePrefix: true\n    });\n  }\n\n  if (titles != null && !Array.isArray(titles)) {\n    titles = Object.keys(titles);\n  }\n\n  return wikiUtils.getMatches(eTyFiltAutoPrefix + filter, titles);\n\n};\n\nexport const isEdgeTypeMatch = (title, filter = '') =>\n  wikiUtils.isMatch(title, eTyFiltAutoPrefix + filter);\n\n/**\n *\n */\nexport const groupByProperty = (col, prop) => {\n\n  col = getIterableCollection(col);\n\n  const result = basicUtils.makeHashMap();\n  const keys = Object.keys(col);\n\n  for (let i in keys) {\n\n    const item = col[keys[i]];\n    const val = item[prop];\n\n    if (val == null) { // null or undefined\n\n      // @todo use exception class\n      throw 'Cannot group by property ' + prop;\n\n    } else {\n\n      if (!Array.isArray(result[val])) {\n        result[val] = [];\n      }\n      result[val].push(item);\n\n    }\n  }\n\n  return result;\n\n};\n\n/**\n * Turns the filter expression in a nicely formatted (but unusable)\n * text, making it easier to edit long filter expressions.\n *\n * @param {string} expr - A valid filter expression.\n * @result {string} A formatted (unusable) filter expression.\n */\nexport const getPrettyFilter = expr => {\n\n  // remove outer spaces and separate operands\n  expr = expr.trim().replace('][', '] [');\n\n  // regex to identify operands\n  const re = /[+-]?\\[.+?[\\]\\}\\>]\\]/g;\n\n  // get operands\n  const operands = expr.match(re);\n\n  // replace operands with dummies and trim again to avoid trailing spaces\n  expr = expr.replace(re, ' [] ').trim();\n\n  // turn it into an array\n  const stringsPlusDummies = expr.split(/\\s+/);\n\n  let operandIndex = 0;\n  const parts = [];\n  for (let i = 0, l = stringsPlusDummies.length; i < l; i++) {\n    parts[i] = (stringsPlusDummies[i] === '[]' ? operands[operandIndex++] : stringsPlusDummies[i]);\n  }\n\n  return parts.join('\\n');\n\n};\n\n/**\n * This function will draw a raster on the network canvas that will\n * adjust to the network's current scaling factor and viewport offset.\n *\n * @param {CanvasRenderingContext2D} ctx - The canvas's context passed by vis.\n * @param {number} scaleFactor - The current scale factor of the network.\n * @param {Object} viewCenter - Virtual center point of the view.\n * @param {number} rasterSize - The size of the squares that are drawn.\n * @param {string} color - A string parsed as CSS color value.\n */\nexport const drawRaster = (ctx, scaleFactor, viewCenter, rasterSize, color = '#D9D9D9') => {\n\n  // from now on the most central raster point\n  const { x: centerX, y: centerY } = basicUtils.getNearestRasterPosition(viewCenter, rasterSize);\n\n  const scaledWidth = ctx.canvas.width / scaleFactor;\n  const scaledHeight = ctx.canvas.height / scaleFactor;\n\n  // some extra lines to ensure the canvas is completely filled with lines\n  const extraLines = rasterSize * 2;\n\n  // calculate the space that is required to draw the rasters\n  const hSpace = Math.ceil((scaledWidth / rasterSize) / 2) * rasterSize + extraLines;\n  const vSpace = Math.ceil((scaledHeight / rasterSize) / 2) * rasterSize + extraLines;\n\n  // align the space to the center points and calculate the offsets\n  const left = centerX - hSpace;\n  const right = centerX + hSpace;\n  const top = centerY - vSpace ;\n  const bottom = centerY + vSpace;\n\n  ctx.beginPath();\n\n  // draw vertical lines\n  for (let x = left; x < right; x += rasterSize) {\n    ctx.moveTo(x, top);\n    ctx.lineTo(x, bottom);\n  }\n\n  // draw horizontal lines\n  for (let y = top; y <= bottom; y += rasterSize) {\n    ctx.moveTo(left, y);\n    ctx.lineTo(right, y);\n  }\n\n  ctx.strokeStyle = color;\n  ctx.fillStyle = color;\n  ctx.stroke();\n\n};\n\n/**\n * Updates a dataset.\n *\n * Note: never use the dataset's update() method, it does not properly remove\n * obsolete properties! – use remove and add instead.\n *\n * @param {vis.DataSet} [ds] - The dataset to be updated\n * @param {Hashmap<id, Node>} ltNew - Lookup table that contains the *new* set of nodes.\n */\nexport const refreshDataSet = (ds, ltNew) => {\n\n  const ltOld = ds.get({ returnType: 'Object' });\n\n  const inserted = [];\n  const updated = [];\n  const withoutPosition = [];\n  const removed = [];\n\n  for (let id in ltNew) {\n\n    if (ltOld[id]) { // element already exists in graph\n\n      if (basicUtils.isEqual(ltOld[id], ltNew[id])) {\n        // simply keep element\n        continue;\n      }\n\n      updated.push(id);\n      ds.remove(id);\n\n    } else {\n\n      inserted.push(id);\n\n    }\n\n    if (ltNew[id].x === undefined) {\n      withoutPosition.push(id);\n    }\n\n    ds.add(ltNew[id]);\n  }\n\n  for (let id in ltOld) {\n    if (!ltNew[id]) {\n      removed.push(id);\n      ds.remove(id);\n    }\n  }\n\n  return {\n    withoutPosition,\n    inserted,\n    updated,\n    removed,\n  };\n\n};\n\n/**\n * Returns the tmap id that is stored in a designated field in the tiddler.\n *\n * @param tiddler\n * @return {string} the tmap id of this tiddler\n */\nexport const getId = tiddler => wikiUtils.getTiddler(tiddler).fields['tmap.id'];\n\n/**\n * Returns all other tiddlers that have the same tmap.id field entry.\n *\n * Note: typically tiddlers don't have the same id assigned, however,\n * this can happen when tiddlers are imported or cloned.\n *\n * @param {Tiddler} tiddler\n * @return {array<TiddlerReference>} a list of tiddlers with the same id as the\n *    provided tiddler (excluding the provided tiddler itself).\n */\nexport const getDublicates = tiddler => {\n\n  const id = getId(tiddler);\n\n  if (!id) {\n\n    return [];\n\n  }\n\n  const tiddlers = wikiUtils.getTiddlersWithField('tmap.id', id, {limit: 2});\n  delete tiddlers[wikiUtils.getTiddlerRef(tiddler)];\n\n  return Object.keys(tiddlers);\n\n};\n\n/**\n * Function that searches an array for an object with a property\n * having a certain value.\n *\n * Attention: Not the item itself but the item's key is returned.\n *\n * @param {Collection} col - The collection to search in.\n * @param {string} key - The property name to look for.\n * @param {*} [val] - An optional value that the object's property must have\n *     in order to match.\n * @param {number} [limit] - An optional result limit (>0) to stop the search.\n * @return {Array<Id>} An array containing the indeces of matching items.\n */\nexport const keysOfItemsWithProperty = (col, key, val, limit) => {\n\n  col = getIterableCollection(col);\n\n  const keys = Object.keys(col);\n  const result = [];\n\n  limit = (typeof limit === 'number' ? limit : keys.length);\n\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const index = keys[i];\n    if (typeof col[index] === 'object' && col[index][key]) {\n      if (!val || col[index][key] === val) {\n        result.push(index);\n        if (result.length === limit) {\n          break;\n        }\n      }\n    }\n  }\n\n  return result;\n\n};\n\n/**\n *\n * @param col\n * @param key\n * @param val\n * @return {*}\n */\nexport const keyOfItemWithProperty = (col, key, val) =>\n  keysOfItemsWithProperty(col, key, val, 1)[0];\n\n/**\n * In a collection where all elements have a **distinct** property\n * `lookupKey`, use the value of each element's `lookupKey` as key\n * to identify the object. If no property `lookupKey` is specified,\n * the collection's values are used as keys and `true` is used as value,\n * however, if the used keys are not strings, an error is thrown.\n *\n * @param {Collection} col - The collection for which to create a lookup table.\n * @param {string} [lookupKey] - The property name to use as index in\n *     the lookup table. If not specified, the collection values are tried\n *     to be used as indeces.\n * @return {Hashmap} The lookup table.\n */\nexport const getLookupTable = (col, lookupKey) => {\n\n  col = getIterableCollection(col);\n\n  const lookupTable = basicUtils.makeHashMap();\n  const keys = Object.keys(col);\n\n  for (let i = 0, l = keys.length; i < l; i++) {\n\n    const key = keys[i];\n    const idx = (lookupKey ? col[key][lookupKey] : col[key]);\n    const type = typeof idx;\n\n    if ((type === 'string' && idx !== '') || type === 'number') {\n      if (!lookupTable[idx]) { // doesn't exist yet!\n        lookupTable[idx] = (lookupKey ? col[key] : true);\n        continue;\n      }\n    }\n\n    // @todo use exception class\n    throw new Error(`Cannot use \"${idx}\" as lookup table index`);\n\n  }\n\n  return lookupTable;\n\n};\n\n/**\n * Alias for {@link getLookupTable}\n */\nexport const getArrayValuesAsHashmapKeys = getLookupTable;\n\n/**\n *\n * @param viewLabel\n * @param type\n */\nexport const getSnapshotTitle = (viewLabel, type) =>\n  `Snapshot – ${viewLabel} (${new Date().toDateString()}).${type || 'png'}`;\n"],"sourceRoot":"../../../../../../../src/plugins"}