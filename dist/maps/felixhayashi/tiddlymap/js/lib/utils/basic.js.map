{"version":3,"sources":["felixhayashi/tiddlymap/js/lib/utils/basic.js"],"names":["Object","defineProperty","exports","value","bindTo","getNearestRasterPosition","mod","removeDOMChildNodes","setDomListeners","merge","getRandomLabel","getFirstElementByClassName","pickRandom","hasKeyWithPrefix","getWithoutPrefix","getPropertiesByPrefix","removeArrayElement","isTrue","replaceAll","isInteger","findAndRemoveClassNames","getAncestorWithClass","makeHashMap","getWithoutNewLines","joinAndWrap","parseJSON","hasSubString","inArray","getRandomInt","isEqual","identity","base64","startsWith","getBasename","escapeRegex","hasElements","ucFirst","undefined","_typeof","Symbol","iterator","obj","constructor","prototype","_exception","require","string","toUpperCase","slice","keys","length","str","replace","path","separator","arguments","substring","lastIndexOf","prefix","window","Buffer","toString","btoa","bind","JSON","stringify","sort","map","key","obj1","obj2","min","max","Math","floor","random","needle","haystack","indexOf","sub","data","parse","Error","arr","left","right","join","initialValues","create","enumerable","configurable","writable","hasOwnProperty","el","className","parentNode","document","classList","contains","classNames","i","elements","getElementsByClassName","j","remove","Number","isFinite","defaultReplacement","subStrings","subString","replacement","Array","isArray","confVal","defVal","n","parseInt","isNaN","index","splice","removePrefix","r","p","substr","cls","root","isRequired","text","EnvironmentError","options","adjective","noun","object","plural","_merge","dest","src","_len","sources","_key","l","task","target","listeners","isCapt","event","childNodes","removeChild","divident","divisor","remainder","_ref","raster","x","y","rasterHalf","distPrevX","distPrevY","context","fnNames","fn"],"mappings":"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","file":"../../../../../../felixhayashi/tiddlymap/js/lib/utils/basic.js","sourcesContent":["/* @preserve TW-Guard */\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/lib/utils/basic\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n/* @preserve TW-Guard */\n\nimport {\n  EnvironmentError\n} from '$:/plugins/felixhayashi/tiddlymap/js/exception';\n\n/**\n * Uppercase the first letter of a string.\n */\nexport const ucFirst = string => string && string[0].toUpperCase() + string.slice(1);\n\n/**\n * Function to find out whether an object has any enumerable properties\n * or, in case of an array, elements.\n *\n * @param {Object} obj\n * @return {boolean} True if at least one enumerable property exists,\n *     false otherwise.\n */\nexport const hasElements = obj => Object.keys(obj).length > 0;\n\n/**\n * When we do not know the string, we need to escape it.\n * @deprecated use tw's escapeRegExp instead\n */\nexport const escapeRegex = str => str.replace(/[-$^?.+*[\\]\\\\(){}|]/g, '\\\\$&');\n\n/**\n * Returns the basename of a path.\n * A path is a string with slashes (or another separator).\n *\n * @param {string} path - The path\n * @param {string} [separator='/']\n * @return {string} The basename\n */\nexport const getBasename = (path, separator = '/') => path.substring(path.lastIndexOf(separator) + 1);\n\n/**\n * Helper to increase the code semantics.\n *\n * @param {string} str - The string to work with.\n * @param {string} prefix - The sequence to test.\n * @result {boolean} True if `str` starts with `prefix`, false otherwise.\n */\nexport const startsWith = (str, prefix) => str.substring(0, prefix.length) === prefix;\n\n/**\n * Converts a string to base64 encoding.\n *\n * To do so, we either choose the native btoa browser function or the Buffer class\n * received via scope.\n *\n * @param {string} str\n */\nexport const base64 = typeof window === 'undefined'\n  ? (str => (new Buffer(str)).toString('base64'))\n  : window.btoa.bind(window);\n\n/**\n * If two objects have the same properties, with the same values\n * then identity identity(obj) === identity(obj2) will return true.\n *\n * @param obj\n * @return string\n */\nexport const identity = obj =>\n  (typeof obj === 'object' && obj !== null\n    ?  JSON.stringify(Object.keys(obj).sort().map(key => [ key, obj[key] ]))\n    : null);\n\n/**\n * Returns true if both objects have the same properties\n * @param obj1\n * @param obj2\n */\nexport const isEqual = (obj1, obj2) => identity(obj1) === identity(obj2);\n\n/**\n *\n * @param min\n * @param max\n */\nexport const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min) + min);\n\n/**\n * Checks if a value exists in an array. A strict search is used\n * which means that also the type of the needle in the haystack\n * is checked.\n *\n * @param {*} needle - The searched value.\n * @param {Array} haystack - The array.\n * @return Returns true if needle is found in the array, false otherwise.\n */\nexport const inArray = (needle, haystack) => haystack.indexOf(needle) !== -1;\n\n/**\n * Checks if a string exists in a string.\n */\nexport const hasSubString = (str, sub) => str.indexOf(sub) !== -1;\n\n/**\n * Try to turn the string into a javascript object. If the\n * transformation fails, return the optionally provided `data` object.\n *\n * @param {string} str - The string to parse.\n * @param {*} data - The default value if the operation fails.\n * @return {*} Either the object resulting from the parsing operation\n *     or `undefined` or `data` if the operation failed.\n */\nexport const parseJSON = (str, data) => {\n\n  try {\n\n    return JSON.parse(str);\n\n  } catch (Error) {\n\n    return data;\n\n  }\n\n};\n\n/**\n * Joins all elements of an array into a string where all elements\n * are wrapped between `left` and `right`.\n *\n * @param {Array} arr - The array to perform the join on.\n * @param {string} left - The wrapping string for the left side.\n * @param {string} right - The wrapping string for the right side.\n * @param {string} [separator] - The separator between a wrapped element\n *     and the next one. Defaults to space.\n * @return {string} The wrapped string, e.g. `[[hello]] [[world]]`.\n */\nexport const joinAndWrap = (arr, left, right, separator = ' ') =>\n  left + arr.join(right + separator + left) + right;\n\n/**\n * Remove any newline from a string\n */\nexport const getWithoutNewLines = str =>\n  (typeof str === 'string') ? str.replace(/[\\n\\r]/g, ' ') : str;\n\n\n/**\n * Factory function to return a prototypeless object that is used as\n * map. It only has the property hasOwnProperty in order to to be\n * exchangeble with other framworks that depend on this method like\n * e.g. visjs.\n *\n * @param {Object} [initialValues] - an object whose own properties will be\n *     used to initialize the map.\n */\nexport const makeHashMap = initialValues => {\n\n  const map = Object.create(null);\n  Object.defineProperty(map, 'hasOwnProperty', {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: Object.prototype.hasOwnProperty.bind(map)\n  });\n\n  if (initialValues) {\n    for (let key in initialValues) {\n      if (initialValues.hasOwnProperty(key)) {\n        map[key] = initialValues[key];\n      }\n    }\n  }\n\n  return map;\n\n};\n\n/**\n * If an ancestor that possesses a specified class exists the the\n * element will be returned, otherwise undefined is returned.\n *\n * @param {Element} el\n * @param {string} className\n */\nexport const getAncestorWithClass = (el, className) => {\n\n  if (typeof el !== 'object' || typeof className !== 'string') {\n    return;\n  }\n\n  while (el.parentNode && el.parentNode !== document) {\n    el = el.parentNode;\n    if (el.classList.contains(className)) {\n      return el;\n    }\n  }\n\n};\n\n/**\n * Searches the dom for elements that possess a certain class\n * and removes this class from each element.\n *\n * @param {Array<string>} classNames - The class names to remove.\n */\nexport const findAndRemoveClassNames = function(classNames) {\n\n  for (let i = classNames.length; i--;) {\n    const elements = document.getElementsByClassName(classNames[i]);\n    for (let j = elements.length; j--;) {\n      elements[j].classList.remove(classNames[i]);\n    }\n  }\n\n};\n\n/**\n * Polyfill until `isInteger` has become official. If the target\n * value is an integer, return true, otherwise return false.\n * If the value is NaN or infinite, return false.\n *\n * @param {*} value - The value to be tested for being an integer.\n * @return {boolean} True if the value is an integer, false otherwise.\n */\nexport const isInteger = Number.isInteger || function(value) {\n  return typeof value === 'number' &&\n         isFinite(value) &&\n         Math.floor(value) === value;\n};\n\n/**\n *\n * @param {string} str\n * @param defaultReplacement\n * @param subStrings\n * @return {*}\n */\nexport const replaceAll = (str, defaultReplacement = '', subStrings) => {\n\n  for (let i = subStrings.length; i--;) {\n\n    let subString = subStrings[i];\n    let replacement = defaultReplacement;\n\n    if (Array.isArray(subString)) {\n      replacement = subString[1];\n      subString = subString[0];\n    }\n\n    str = str.replace(subString, replacement);\n  }\n\n  return str;\n\n};\n\n/**\n * Sadly, setting fields with tw means that we lose the type information\n * since field values are persisted as strings and the type is not\n * included.\n *\n * To ensure that flags are always interpreted correctly, the following\n * function exists.\n *\n * We regard the following values as `true` (order matters):\n *\n * # Any string that can be translated into a number unequal `0`\n * # `\"true\"`\n * # Any number unequal `0`\n * # Boolean `true`\n *\n * The following as false (order matters):\n *\n * # Any string that can be translated into number `0`\n * # Every string unequal `\"true\"`\n * # The number `0`\n * # Boolean `false`\n *\n */\nexport const isTrue = (confVal, defVal) => {\n\n  if (confVal == null) {\n    return !!defVal;\n  } else if (typeof confVal === 'string') {\n    var n = parseInt(confVal);\n    return (isNaN(n) ? (confVal === 'true') : (n !== 0));\n  } else if (typeof confVal === 'boolean') {\n    return confVal;\n  } else if (typeof confVal === 'number') {\n    return (n !== 0);\n  }\n\n  return false;\n\n};\n\n/**\n * If the array contains the element, the element is removed from\n * the array in-place and the removed element.\n */\nexport const removeArrayElement = (arr, el) => {\n\n  const index = arr.indexOf(el);\n  if (index > -1) {\n    return arr.splice(index, 1)[0];\n  }\n\n};\n\n/**\n * Returns a new object that contains only properties that start with\n * a certain prefix. The prefix is optionally removed from the result.\n *\n * @param {Object} obj\n * @param {string} prefix - The start sequence\n * @param {boolean} [removePrefix=false] - True if the prefix shall be removed\n *     from the resulting property name, false otherwise.\n * @result {object}\n */\nexport const getPropertiesByPrefix = (obj, prefix, removePrefix) => {\n\n  const r = makeHashMap();\n  for (let p in obj) {\n    if (startsWith(p, prefix)) {\n      r[(removePrefix ? p.substr(prefix.length) : p)] = obj[p];\n    }\n  }\n\n  return r;\n\n};\n\n/**\n * Function to remove the prefix of a string\n */\nexport const getWithoutPrefix =\n  (str, prefix) => startsWith(str, prefix) ? str.substr(prefix.length) : str;\n\n\n/**\n *\n */\nexport const hasKeyWithPrefix = (obj, prefix) => {\n\n  for (let p in obj) {\n    if (startsWith(p, prefix)) {\n      return true;\n    }\n  }\n\n  return false;\n\n};\n\n/**\n *\n * @param arr\n */\nexport const pickRandom = arr => arr[getRandomInt(0, arr.length-1)];\n\n//~ utils.getNestedProperty = function(obj, propPath) {\n//~\n  //~ propPath = propPath.split(\".\");\n  //~ for (var i = propPath.length; i--;) {\n    //~ if (obj !== null && typeof obj === \"object\") {\n      //~ obj = obj[propPath[i]];\n  //~ }\n  //~\n//~ };\n\n/**\n * Works like get `getElementById()` but is based on a class name.\n * It will return the first element inside an optional parent (root)\n * that has a class of this name.\n *\n * @param {string} cls - The class name to search for.\n * @param {Element} [root=document] - The context to search in.\n * @param {boolean} [isRequired=true] - If true, an exception will be\n *     thrown if no element can be retrieved. This is important\n *     when depending on third party modules and class names change!\n * @throws {EnvironmentError} - May be thrown if\n *    `isRequired` is set to true.\n * @return {Element} Either a dom element or null is returned.\n */\nexport const getFirstElementByClassName = (cls, root, isRequired) => {\n\n  const el = (root || document).getElementsByClassName(cls)[0];\n  if (!el && (typeof isRequired === 'boolean' ? isRequired : true)) {\n    const text = `Missing element with class \"${cls}\" inside ${root}`;\n    throw new EnvironmentError(text);\n  }\n\n  return el;\n\n};\n\nexport const getRandomLabel = (options = {}) => {\n\n  const adjective = pickRandom([\n    'exciting', 'notable', 'epic', 'new', 'fancy',\n    'great', 'cool', 'fresh', 'funky', 'clever'\n  ]);\n\n  const noun = (options.object || pickRandom([\n    'concept', 'idea', 'thought', 'topic', 'subject'\n  ])) + (options.plural ? 's' : '');\n\n  return `My ${adjective} ${noun}`;\n\n};\n\nconst _merge = (dest, src) => {\n\n  if (typeof dest !== 'object') {\n    dest = {};\n  }\n\n  for (let p in src) {\n    if (src.hasOwnProperty(p)) {\n      if (src[p] != null) { // skip null or undefined\n        dest[p] = (typeof src[p] === 'object'\n          ? _merge(dest[p], src[p])\n          : src[p]); // primitive type, stop recursion\n      }\n    }\n  }\n\n  return dest;\n\n};\n\n/**\n * Merges `src` into `dest` which means that the merge transforms\n * the `dest` object itself. If src and dest both have the same\n * property path, src does only replace the primitive data type\n * at the end of the path.\n *\n * @todo Should null really be skipped or treated as value?\n *\n * @param {Object} dest - The destination object.\n * @param {...Object} sources - At least one object to merge into `dest`.\n * @return {Object} The original `dest` object.\n */\nexport const merge = (dest, ...sources) => {\n\n  // start the merging; i = 1 since first argument is the destination\n  for (let i = 0, l = sources.length; i < l; i++) {\n    const src = sources[i];\n    if (src != null && typeof src === 'object') {\n      dest = _merge(dest, src);\n    }\n  }\n\n  return dest;\n\n};\n\n/**\n * Adds or removes listeners from the target in capture or\n * non-capture (bubbling) mode.\n *\n * @param {string} task - Either \"add\" or \"remove\". Make sure to\n *     always call add and remove with *excatly* the same listeners\n *     Note: if you use bind, you change the function object.\n * @param {Element} target - The element to attach or remove the\n *     listener to or from.\n * @param {Object<string, (Function|Array)>} listeners - The key is\n *     the event name and the value is either a handler function\n *     or an array where the first index is the handler function and\n *     the second is a boolean that specifies whether to use capture\n *     or not.\n * @param {boolean} [isCapt=false] - Whether to run the handler in\n *     bubbling or capturing phase.\n */\nexport const setDomListeners = (task, target, listeners, isCapt) => {\n\n  isCapt = (typeof isCapt === 'boolean' ? isCapt : false);\n  task = task + 'EventListener';\n\n  for (let event in listeners) {\n\n    const l = listeners[event];\n\n    if (typeof l === 'function') {\n\n      target[task](event, l, isCapt);\n    } else { // expect Array\n\n      target[task](event, l[0], (typeof l[1] === 'boolean' ? l[1] : isCapt));\n    }\n\n  }\n\n};\n\n/**\n * Removes all child nodes of a DOM element. This includes element\n * and non-element objects.\n */\nexport const removeDOMChildNodes = el => {\n\n  for (let i = el.childNodes.length; i--;) {\n    el.removeChild(el.childNodes[i]);\n  }\n\n};\n\n/**\n * Implementation of the algebraic modulus operation.\n *\n * In javascript '%' is really a remainder operator, not a modulus.\n * Algebraically speaking, a modulus operation always yields\n * positive results, while '%' in js can yield negative results.\n *\n * Note: divident mod divisor\n *\n * @param {number} divident\n * @param {number} divisor\n * @return {number}\n */\nexport const mod = (divident, divisor) => {\n\n  const remainder = divident % divisor;\n\n  return Math.floor(remainder >= 0 ? remainder : remainder + divisor);\n\n};\n\n/**\n * Maps a coordinate to the nearest raster coordinate.\n *\n * @param {number} x\n * @param {number} y\n * @param {number} raster\n * @return {{x: number, y: number}}\n */\nexport const getNearestRasterPosition = ({ x, y }, raster) => {\n\n  const rasterHalf = raster / 2;\n\n  // calculate distances to previous raster lines\n  const distPrevX = mod(x, raster);\n  const distPrevY = mod(y, raster);\n\n  return {\n    x: distPrevX < rasterHalf ? x - distPrevX : x - distPrevX + raster,\n    y: distPrevY < rasterHalf ? y - distPrevY : y - distPrevY + raster\n  };\n\n};\n\n/**\n * Force early binding of functions to this context.\n *\n * @param context the context to bind this function to (typically `this`)\n * @param {Array<string>} fnNames - The prototype function names\n *     to bind to this context.\n */\nexport const bindTo = (context, fnNames) => {\n\n  for (let i = fnNames.length; i--;) {\n    const fn = context[fnNames[i]];\n    context[fnNames[i]] = fn.bind(context);\n  }\n\n};\n"],"sourceRoot":"../../../../../../../src/plugins"}