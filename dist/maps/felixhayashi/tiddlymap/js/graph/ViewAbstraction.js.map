{"version":3,"sources":["felixhayashi/tiddlymap/js/graph/ViewAbstraction.js"],"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_typeof","Symbol","iterator","obj","constructor","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","Constructor","protoProps","staticProps","_EdgeType","require","_EdgeType2","_interopRequireDefault","_utils","_utils2","_environment","env","_interopRequireWildcard","_exception","__esModule","newObj","default","_classCallCheck","instance","TypeError","ViewAbstraction","view","options","undefined","this","_registerPaths","isCreate","configTRef","name","utils","getRandomLabel","plural","$tw","wiki","generateNewTitle","$tm","path","views","_createView","exists","getRoot","ResourceNotFoundException","isLocked","isShadowTiddler","update","updates","changedTiddlers","edgeTypes","hasKeyWithPrefix","_clearCaches","addPlaceholder","tiddler","cp","getTiddlerRef","snapshotTRef","getCreationDate","asString","date","getTiddler","fields","Date","formatDateString","getLabel","getBasename","destroy","deleteTiddlers","getMatches","getOccurrences","filter","rename","newLabel","inArray","notify","oldLabel","newRoot","oldRoot","mv","config","sys","defaultView","setEntry","ref","sysUserConf","liveTab","fallbackView","each","tObj","tRef","setField","nodes","getNodeData","id","saveNodeData","isEnabled","isTrue","getConfig","_this","getCacheForTiddler","getPropertiesByPrefix","prefixlessName","startsWith","setConfig","_len","args","Array","_key","prop","getWithoutPrefix","val","logger","match","addTiddler","Tiddler","Function","bind","apply","InvalidArgumentException","concat","isLiveView","misc","liveViewLabel","isNodeIncludedById","node","regex","escapeRegExp","_getNodeIdFilterPart","getNodeFilter","setNodeFilter","expr","force","replace","nodeFilterTRef","setEdgeTypeFilter","getEdgeTypeFilter","edgeTypeFilterTRef","addNode","alwaysAddNodeIdToViewFilter","isMatch","part","separator","saveNodePosition","removeNode","nodeId","f","type","_this2","allETy","indeces","src","keys","raw","pretty","getPrettyFilter","matches","getEdgeTypeMatches","whitelist","getLookupTable","isEdgeTypeVisible","isEdgeTypeMatch","EdgeType","getInstance","_this3","makeHashMap","compiled","compileFilter","_this4","data","mapTRef","parseFieldData","equals","_len2","_key2","writeFieldData","jsonIndentation","x","y","saveNodePositions","positions","nodeData","setCentralTopic","saveNodeStyle","style","pos","p","_getRootPath","forEach","clearCache","_ref","isForce","protoView","isHidden","title","genUUID","field","viewMarker","defaultEdgeTypeFilter","label","hasSubString","tiddlerExists"],"mappings":"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","file":"../../../../../felixhayashi/tiddlymap/js/graph/ViewAbstraction.js","sourcesContent":["/* @preserve TW-Guard */\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n/* @preserve TW-Guard */\n\n/*** Imports *******************************************************/\n\nimport EdgeType from '$:/plugins/felixhayashi/tiddlymap/js/EdgeType';\nimport utils    from '$:/plugins/felixhayashi/tiddlymap/js/utils';\nimport * as env from '$:/plugins/felixhayashi/tiddlymap/js/lib/environment';\nimport {\n  InvalidArgumentException,\n} from '$:/plugins/felixhayashi/tiddlymap/js/exception';\n\n/*** Code **********************************************************/\n\n/**\n * This class abstracts the various pieces that together make up the\n * view such as map, edge filter, node filter, config etc.\n * If {@code isCreate} is not specified, the viewAbstraction will only\n * represent the view and not create it or any missing part of it.\n */\nclass ViewAbstraction {\n\n  /**\n   *\n   * @param {string|ViewAbstraction|Tiddler} view - The view\n   * @param {Object} options\n   * @param {boolean} [options.isCreate] - True if the view should be created and override\n   *     any existing view, false otherwise.\n   */\n  constructor(view, options = {}) {\n\n    if (view instanceof ViewAbstraction) {\n\n      // bounce back the object we received\n      return view;\n\n    }\n\n    this._registerPaths(view);\n\n    if (options.isCreate) {\n\n      if (!this.configTRef) {\n\n        const name = utils.getRandomLabel({plural: true});\n        this.configTRef = $tw.wiki.generateNewTitle(`${$tm.path.views}/${name}`);\n\n      }\n\n      this._createView(options);\n\n    } else if (!ViewAbstraction.exists(this.getRoot())) { // no valid config path\n\n      throw new ResourceNotFoundException('ViewAbstraction', view);\n\n    }\n\n  }\n\n  /**\n   * Returns true if this view cannot be edited.\n   * As a general rule, all views that come as plugins are locked.\n   *\n   * @return {boolean}\n   */\n  isLocked() {\n\n    return $tw.wiki.isShadowTiddler(this.configTRef);\n\n  }\n\n  /**\n   * Gives the view a chance to rebuild its properties cache.\n   *\n   * @param {Updates} updates\n   * @return {boolean} True if changes affect parts of the view.\n   */\n  update(updates) {\n\n    const { changedTiddlers } = updates;\n\n    if (updates[env.path.edgeTypes] || utils.hasKeyWithPrefix(changedTiddlers, this.getRoot())) {\n      this._clearCaches();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * clones the tiddler denoted via tRef and uses it as placeholder\n   * for this view when a widget using this view is displayed in\n   * static mode\n   *\n   * @param {Tiddler} tiddler\n   */\n  addPlaceholder(tiddler) {\n\n    utils.cp(utils.getTiddlerRef(tiddler), this.snapshotTRef, true);\n\n  }\n\n  /**\n   * A view exists if the the view's root exists as tiddler in the store.\n   *\n   * @deprecated\n   *\n   * @return {boolean}\n   */\n  exists() {\n\n    return ViewAbstraction.exists(this);\n\n  }\n\n  /**\n   * The path to the config tiddler that represents the view.\n   *\n   * @return {TiddlerReference}\n   */\n  getRoot() {\n\n    return this.configTRef;\n\n  }\n\n  /**\n   * Returns this view's creation date.\n   *\n   * @param {boolean} [asString] True if the returned value should be a string in any case.\n   * @return {string|object|undefined} The creation date in the specified output format.\n   */\n  getCreationDate(asString) {\n\n    const date = $tw.wiki.getTiddler(this.configTRef).fields['created'];\n\n    if (asString) {\n      // note: th will be translated as well!\n      return (date instanceof Date ? $tw.utils.formatDateString(date, 'DDth MMM YYYY') : '');\n    }\n\n    return date;\n\n  }\n\n  /**\n   * The label of the view (which is basically the root-path's basename).\n   *\n   * @return {string} The label (name) of the view.\n   */\n  getLabel() {\n\n    return utils.getBasename(this.configTRef);\n\n  }\n\n  /**\n   * Method to remove the view and its configuration.\n   * It will make the view non-existent.\n   *\n   * Note: Do not use the object anymore after you called this function!\n   */\n  destroy() {\n\n    // delete the view and all tiddlers stored in its path (map, edge-filter etc.)\n    utils.deleteTiddlers(utils.getMatches(`[prefix[${this.configTRef}]]`));\n\n  }\n\n  /**\n   * Returns all tiddlers include tiddlymap widgets that reference this view.\n   */\n  getOccurrences() {\n\n    const filter = `[regexp:text[<\\\\$(tiddlymap|tmap).*?view=.${this.getLabel()}..*?>]]`;\n    return utils.getMatches(filter);\n\n  }\n\n  /**\n   * Renames the view.\n   *\n   * @param {string} newLabel\n   * @return {boolean}\n   */\n  rename(newLabel) {\n\n    if (typeof newLabel !== 'string') {\n\n      return false;\n    }\n\n    if (utils.inArray('/', newLabel)) {\n\n      $tm.notify('A view name must not contain any \"/\"');\n\n      return false;\n    }\n\n    // keep a reference to the old label before we change it\n    const oldLabel = this.getLabel();\n\n    // start the renaming\n    const newRoot = env.path.views + '/' + newLabel;\n    const oldRoot = this.getRoot();\n\n    utils.mv(oldRoot, newRoot, true);\n\n    // update references\n\n    if ($tm.config.sys.defaultView === oldLabel) {\n      utils.setEntry($tm.ref.sysUserConf, 'defaultView', newLabel);\n    }\n\n    if ($tm.config.sys.liveTab.fallbackView === oldLabel) {\n      utils.setEntry($tm.ref.sysUserConf, 'liveTab.fallbackView', newLabel);\n    }\n\n    $tw.wiki.each((tObj, tRef) => {\n\n      if (tObj.fields['tmap.open-view'] === oldLabel) {\n\n        // update global node data fields referencing this view\n        utils.setField(tRef, 'tmap.open-view', newLabel);\n\n        return;\n\n      }\n\n      if (ViewAbstraction.exists(tRef)) {\n\n        // update all local node data referencing this view\n        const view = new ViewAbstraction(tRef);\n        const nodes = view.getNodeData();\n\n        for (let id in nodes) {\n          if (nodes[id]['open-view'] === oldLabel) {\n            nodes[id]['open-view'] = newLabel;\n          }\n        }\n\n        view.saveNodeData(nodes);\n\n      }\n\n    });\n\n    // clear caches registered to previous root before registering new paths\n    this._clearCaches();\n    this._registerPaths(newLabel);\n\n  }\n\n  /**\n   * All configurations that are toggled via checkboxes to have a value\n   * either `true` or `false` can be accessed via this method.\n   *\n   * @param {string} name - The configs name without the `_config` prefix.\n   * @return {boolean} True if the configuration is enabled, false otherwise.\n   */\n  isEnabled(name) {\n\n    return utils.isTrue(this.getConfig(name), false);\n\n  }\n\n  /**\n   * Returns a configuration value relating to the given name. If no name\n   * is given, an object with all configurations is returned.\n   *\n   * @param {string} [name] - Instead of all configurations being returned,\n   *     only the configuration named name is returned. The initial \"config.\"\n   *     may be omitted.\n   * @result {string|Object} If `type` is not specified an object containing\n   *     all configurations is returned, otherwise a single value will be returned.\n   */\n  getConfig(name) {\n\n    const config = $tw.wiki.getCacheForTiddler(this.configTRef, \"tmap-config\", () => {\n\n      const fields = utils.getTiddler(this.configTRef).fields;\n      return utils.getPropertiesByPrefix(fields, 'config.');\n\n    });\n\n    const prefixlessName = name && utils.startsWith(name, 'config.') ? name : `config.${name}`;\n\n    return (name ? config[prefixlessName] : config);\n\n  }\n\n  /**\n   * Enables the api user to modify the view's configuration.\n   *\n   * In case two arguments are provided, the first is assumed to be the property\n   * name and the second the value to be set.\n   *\n   * In case a single object is provided as argument, it is treated as a key-value\n   * collection and each property in this object is saved as config.\n   *\n   * @param {*} args\n   */\n  setConfig(...args) {\n\n    if (args[0] == null) { // null or undefined\n\n      return;\n    }\n\n    if (args.length === 1 && typeof args[0] === 'object') {\n\n      for (let prop in args[0]) {\n        this.setConfig(prop, args[0][prop]);\n      }\n\n    } else if (args.length === 2 && typeof args[0] === 'string') {\n\n      const prop = utils.getWithoutPrefix(args[0], 'config.');\n      let val = args[1];\n\n      if (val === undefined) {\n\n        return;\n      }\n\n      const config = this.getConfig();\n\n      if (val === null) {\n\n        $tm.logger('debug', 'Removing config', prop);\n        delete config[`config.${prop}`];\n\n      } else {\n\n        if (prop === 'edge_type_namespace') {\n          const match = val.match(/[^:]+/);\n          val = (match ? match[0] : '');\n        }\n\n      }\n\n      $tm.logger('log', 'Setting config', prop, val);\n      config[`config.${prop}`] = val;\n\n      // save\n      $tw.wiki.addTiddler(new $tw.Tiddler(\n        utils.getTiddler(this.configTRef),\n        config\n      ));\n\n    } else { // not allowed\n\n      throw new InvalidArgumentException(...args);\n\n    }\n\n  }\n\n  /**\n   * Whether this view represents the 'live view'\n   *\n   * @return {boolean}\n   */\n  isLiveView() {\n\n    return (this.getLabel() === $tm.misc.liveViewLabel);\n\n  }\n\n  /**\n   * Whether the node is already explicitly contained in the view's node filter,\n   * i.e. whether it is explicitly referenced by its title.\n   *\n   * @private\n   *\n   * @param {Node} node\n   * @return {string}\n   */\n  isNodeIncludedById(node) {\n\n    const regex = $tw.utils.escapeRegExp(ViewAbstraction._getNodeIdFilterPart(node));\n\n    return this.getNodeFilter('raw').match(regex);\n\n  }\n\n  /**\n   * Sets and rebuilds the node filter according to the expression provided.\n   *\n   * @param {string} expr - A tiddlywiki filter expression.\n   * @param {boolean} force\n   */\n  setNodeFilter(expr, force) {\n\n    expr = expr.replace(/[\\n\\r]/g, ' ');\n\n    if (this.getNodeFilter('raw') === expr) {\n      // already up to date;\n      // This check is critical to prevent recursion!\n      return;\n    }\n\n    utils.setField(this.nodeFilterTRef, 'filter', expr);\n\n    $tm.logger('debug', 'Node filter set to', expr);\n\n  }\n\n  /**\n   * Sets and rebuilds the edge type filter according to the expression provided.\n   *\n   * @param {string} expr - A tiddlywiki filter expression.\n   */\n  setEdgeTypeFilter(expr) {\n\n    expr = expr.replace(/[\\n\\r]/g, ' ');\n\n    if (this.getEdgeTypeFilter('raw') === expr) { // already up to date\n      // This check is critical to prevent recursion!\n      return;\n    }\n\n    utils.setField(this.edgeTypeFilterTRef, 'filter', expr);\n\n    $tm.logger('debug', 'Edge filter set to', expr);\n\n  }\n\n  /**\n   * Method to append a filter part to the current filter (*or*-style).\n   * The node's tmap.id will be used in the filter to reference the corresponding tiddler.\n   *\n   * @param {Node} node\n   */\n  addNode(node) {\n\n    if (!this.isNodeIncludedById(node)) {\n\n      // @see https://github.com/felixhayashi/TW5-TiddlyMap/issues/285\n      if (\n        utils.isTrue($tm.config.sys.alwaysAddNodeIdToViewFilter) ||\n        !utils.isMatch(node.tRef, this.getNodeFilter('compiled'))\n      ) {\n\n        const part = ViewAbstraction._getNodeIdFilterPart(node);\n        const separator = ' ';\n        this.setNodeFilter(this.getNodeFilter('raw') + separator + part);\n\n      }\n\n      this.saveNodePosition(node);\n\n    }\n\n  }\n\n  /**\n   * Removes a node from the the view filter that has been\n   * explicitly added before.\n   *\n   * ATTENTION: Never remove the node data (i.e. style and positions)\n   * from the node-data store. This will be done by a garbage\n   * collector. See Adapter.prototype._removeObsoleteViewData\n   *\n   * @return {boolean} True if node was removed, false otherwise.\n   *     Note: false is also returned if the node did not exist before.\n   */\n  removeNode(nodeId) {\n\n    if (!this.isNodeIncludedById(nodeId)) {\n\n      return false;\n    }\n\n    const part = ViewAbstraction._getNodeIdFilterPart(nodeId);\n    const f = this.getNodeFilter('raw').replace(part, '');\n\n    this.setNodeFilter(f);\n\n    // if (this.getNodeData(nodeId)) {\n    //   this.saveNodeData(nodeId, null);\n    // }\n\n    return true;\n\n  }\n\n  /**\n   * Method will return a tiddlywiki edge-type filter that is used to\n   * decide which edge types are displayed by the graph.\n   *\n   * Note: needs to be recalculated if the collection of edge types changed\n   * in the wiki.\n   *\n   * @param {(\"raw\"|\"pretty\"|\"matches\"|\"whitelist\")} [type]\n   *     Use this param to control the output type.\n   * @result {*}\n   *     Depends on the type param:\n   *     - raw: the original filter string\n   *     - pretty: the prettyfied filter string for usage in textareas\n   *     - matches: {Array<string>} all matches\n   *     - whitelist: A lookup table where all matches are true\n   */\n  getEdgeTypeFilter(type) {\n\n    const filter = $tw.wiki.getCacheForTiddler(this.edgeTypeFilterTRef, \"tmap-edgeTypeFilter\", () => {\n\n      const allETy = $tm.indeces.allETy;\n      const src = Object.keys(allETy);\n      const tObj = $tw.wiki.getTiddler(this.edgeTypeFilterTRef);\n\n      let filter = {};\n      filter.raw = (tObj && tObj.fields.filter || '');\n      filter.pretty = utils.getPrettyFilter(filter.raw);\n      filter.matches = utils.getEdgeTypeMatches(filter.raw, allETy);\n      filter.whitelist = utils.getLookupTable(filter.matches);\n\n      return filter;\n\n    });\n\n    return (type ? filter[type] : filter);\n\n  }\n\n  /**\n   * Whether or not this EdgeType is visible in this view.\n   *\n   * @param {EdgeType|string} id\n   * @return {*}\n   */\n  isEdgeTypeVisible(id) {\n\n    return utils.isEdgeTypeMatch(EdgeType.getInstance(id).id, this.getEdgeTypeFilter(\"raw\"));\n\n  }\n\n  /**\n   * Method will return a tiddlywiki node filter that is used to\n   * decide which nodes are displayed by the graph.\n   *\n   * @param {(\"raw\"|\"pretty\"|\"compiled\")} [type] - Use this param to control the output type.\n   * @result {*}\n   *     Depends on the type param:\n   *     - raw: the original filter string\n   *     - pretty: the prettyfied filter string for usage in textareas\n   *     - compiled: {Array<string>} all matches\n   */\n  getNodeFilter(type) {\n\n    const filter = $tw.wiki.getCacheForTiddler(this.nodeFilterTRef, \"tmap-nodeFilter\", () => {\n\n      let filter = utils.makeHashMap();\n      const tObj = $tw.wiki.getTiddler(this.nodeFilterTRef);\n\n      filter.raw = (tObj && tObj.fields.filter) || '';\n      filter.pretty = utils.getPrettyFilter(filter.raw);\n      filter.compiled = $tw.wiki.compileFilter(filter.raw);\n\n      return filter;\n\n    });\n\n    return (type ? filter[type] : filter);\n\n  }\n\n  /**\n   * This method will return the node data stored in the view.\n   *\n   * @todo When to delete obsolete data?\n   *\n   * @param {string} nodeId\n   * @result {Hashmap<Id, Object>} A Hashmap with node data.\n   */\n  getNodeData(nodeId) {\n\n    const data = $tw.wiki.getCacheForTiddler(this.mapTRef, \"tmap-map\", () => utils.parseFieldData(this.mapTRef, 'text', {}));\n\n    return (nodeId ? data[nodeId] : data);\n\n  }\n\n  /**\n   * A view equals another view either\n   *\n   * 1) if the js objects reference the same objects in the js runtime\n   * 2) or if the views have the same root and both views exist\n   *\n   * @param view\n   * @return {boolean}\n   */\n  equals(view) {\n\n    return view === this\n      || (ViewAbstraction.exists(view) && (new ViewAbstraction(view)).getRoot() === this.getRoot());\n\n  }\n\n  /**\n   * This function will merge the given data in the view's node store.\n   *\n   * If a property is set to null, it will be removed.\n   *\n   * If two arguments are provided, the first parameter is assumed\n   * to be a node id and the second to be the data object. The data\n   * will extend the existing data. If data is not an object, it is\n   * assumed to be a delete directive and consequently the node data\n   * in the store will be deleted.\n   *\n   * Otherwise, if a single object parameter is provided, it is regarded\n   * as a node collection and the whole object is used to extend the store.\n   *\n   * Note: The Adapter will routinely delete node content of nodes that are\n   * not contained in the view anymore.\n   */\n  saveNodeData(...args) {\n\n    const data = this.getNodeData();\n\n    if (args.length === 2) {\n\n      if (typeof args[1] === 'object') {\n\n        if (args[1] === null) {\n\n          delete data[args[0]];\n\n        } else {\n\n          data[args[0]] = Object.assign(data[args[0]] || {}, args[1]);\n        }\n      }\n\n    } else if (args.length === 1 && typeof args[0] === 'object') {\n\n      $tm.logger('log', 'Storing data in', this.mapTRef);\n\n      Object.assign(data, args[0]);\n\n    } else { // not allowed\n\n      throw new InvalidArgumentException(...args);\n    }\n\n    utils.writeFieldData(this.mapTRef, 'text', data, $tm.config.sys.jsonIndentation);\n\n  }\n\n  /**\n   * Saves a node's position to the store\n   *\n   * @param {Node} node\n   */\n  saveNodePosition(node) {\n\n    if (node.id && node.x != null && node.y != null) {\n      // only pass coordinates to prevent other data from being stored!\n      this.saveNodeData(node.id, { x: node.x, y: node.y });\n    }\n\n  }\n\n  /**\n   * Saves a node's position to the store\n   *\n   * @param {Object} positions\n   */\n  saveNodePositions(positions) {\n\n    const nodeData = this.getNodeData();\n\n    for (let id in positions) {\n\n      nodeData[id] = nodeData[id] || {};\n      nodeData[id].x = positions[id].x;\n      nodeData[id].y = positions[id].y;\n\n    }\n\n    this.saveNodeData(nodeData);\n\n  }\n\n  /**\n   * Marks the node with the given id as central topic.\n   *\n   * @param nodeId\n   */\n  setCentralTopic(nodeId) {\n\n    this.setConfig('central-topic', nodeId);\n\n  }\n\n  /**\n   * Saves the provided style for the node with the specified id in the view's store.\n   *\n   * Note: The coordinates of the node on the map are not stored via this function.\n   * For this task, use saveNodePosition() instead.\n   *\n   * @param {string} nodeId\n   * @param {Object} style\n   */\n  saveNodeStyle(nodeId, style) {\n\n    // remove any previos style from store;\n    // @TODO: optimize this only null in style var needs to be removed\n    const data = this.getNodeData(nodeId) || {};\n\n    const pos = { x: data.x, y: data.y };\n\n    // tabula rasa! delete all previous properties\n    for (let p in data) {\n      delete data[p];\n    }\n\n    // save new style\n    this.saveNodeData(nodeId, {\n      ...style,\n      ...pos\n    });\n\n  }\n\n  /**\n   * The view's configTiddlerRef is stored in different tiddlers (paths).\n   * This function registers these paths to this the view instance.\n   *\n   * @private\n   * @params {ViewAbstraction|string} view\n   */\n  _registerPaths(view, isCreate) {\n\n    // main config is stored here\n    this.configTRef = ViewAbstraction._getRootPath(view);\n\n    // store for node properties (positions and local node styles)\n    this.mapTRef = `${this.configTRef}/map`;\n\n    // filter stores\n    this.nodeFilterTRef = `${this.configTRef}/filter/nodes`;\n    this.edgeTypeFilterTRef = `${this.configTRef}/filter/edges`;\n\n    this.snapshotTRef = `${this.getRoot()}/snapshot`;\n\n  }\n\n  /**\n   * This will clear all cached tiddlers related to this view.\n   *\n   * @private\n   * @return {boolean} true if the cache was dirty, false if cache was up-to-date and did\n   */\n  _clearCaches() {\n    // clear all tiddler-caches below this path\n    utils\n      .getMatches(`[prefix[${this.getRoot()}]]`)\n      .forEach(tRef => { $tw.wiki.clearCache(tRef); });\n  }\n\n  /**\n   * Will create the config tiddler which means that the view will\n   * start to exist.\n   *\n   * @private\n   */\n  _createView({ isForce, protoView, isHidden } = {}) {\n\n    // destroy any former view that existed in this path\n    if (ViewAbstraction.exists(this)) {\n\n      if (!isForce) {\n\n        return;\n\n      }\n\n      this.destroy();\n    }\n\n    if (ViewAbstraction.exists(protoView)) {\n      utils.cp((new ViewAbstraction(protoView)).getRoot(), this.configTRef, true);\n    }\n\n    // create new view\n    const fields = {\n      title: this.configTRef,\n      id: utils.genUUID(), // maybe useful for future purposes…\n    };\n\n    if (!isHidden) {\n      fields[$tm.field.viewMarker] = true;\n    }\n\n    $tw.wiki.addTiddler(new $tw.Tiddler(\n      utils.getTiddler(this.configTRef), // in case we cloned the view\n      fields\n    ));\n\n    this.setEdgeTypeFilter(env.filter.defaultEdgeTypeFilter);\n\n  }\n\n  /**\n   * Will return a filter part that matches the node's id.\n   *\n   * E.g. [field:tmap.id[1748576e-74bb-4165-85bb-0d312e3e4f1f]]\n   *\n   * @private\n   *\n   * @param node\n   * @return {string}\n   */\n  static _getNodeIdFilterPart(node) {\n\n    const id = (typeof node === 'object' ? node.id : node);\n\n    return `[field:tmap.id[${id}]]`;\n\n  }\n\n  /**\n   * Will return the path to the config tiddler of this view, aka the view's root.\n   *\n   * @private\n   *\n   * @param {*} view - The constructor param to abstract or create the view.\n   * @result {string|undefined} The view config path.\n   */\n  static _getRootPath(view) {\n\n    if (view instanceof ViewAbstraction) {\n\n      return view.configTRef;\n\n    }\n\n    if (view instanceof $tw.Tiddler) { // is a tiddler object\n\n      view  = view.fields.title;\n\n    }\n\n    if (typeof view === 'string') {\n\n      // remove prefix and slash\n      const label = utils.getWithoutPrefix(view, `${$tm.path.views}/`);\n\n      // a valid label must not contain any slashes\n      if (label && !utils.hasSubString(label, '/')) {\n\n        return `${$tm.path.views}/${label}`;\n\n      }\n    }\n\n  }\n\n  /**\n   * A view exists if the the view's root exists as tiddler in the store.\n   *\n   * @return {ViewAbstraction|string}\n   */\n  static exists(view) {\n\n    if (!view) {\n\n      return false;\n    }\n\n    if (view instanceof ViewAbstraction) {\n\n      view = view.configTRef;\n\n    } else {\n\n      view = ViewAbstraction._getRootPath(view);\n    }\n\n    return utils.tiddlerExists(view);\n\n  }\n\n}\n\n/*** Exports *******************************************************/\n\nexport default ViewAbstraction;\n"],"sourceRoot":"../../../../../../src/plugins"}