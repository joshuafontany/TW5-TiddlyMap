{"version":3,"sources":["felixhayashi/tiddlymap/js/graph/MapElementType.js"],"names":["Object","defineProperty","exports","value","_typeof","Symbol","iterator","obj","constructor","prototype","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","_utils","require","_utils2","_interopRequireDefault","__esModule","default","_classCallCheck","instance","TypeError","MapElementType","id","root","fieldMeta","data","this","_fieldMeta","fullPath","isShipped","$tw","wiki","getSubTiddler","$tm","path","pluginRoot","_load","isFullPath","utils","startsWith","tRef","_loadFromTiddler","Tiddler","field","tiddler","tObj","getTiddler","shadowTObj","rawData","extend","fields","parser","parse","rawVal","call","exists","tiddlerExists","setStyle","style","isMerge","parseJSON","merge","save","silently","title","text","stringify","assign","getCreationFields","getModificationFields","addTiddler","description","JSON","modified","created"],"mappings":"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","file":"../../../../../felixhayashi/tiddlymap/js/graph/MapElementType.js","sourcesContent":["/* @preserve TW-Guard */\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/MapElementType\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n/* @preserve TW-Guard */\n\n/*** Imports *******************************************************/\n\nimport utils from '$:/plugins/felixhayashi/tiddlymap/js/utils';\n\n/*** Code **********************************************************/\n\n/**\n * @abstract\n */\nclass MapElementType {\n\n  constructor(id, root, fieldMeta, data) {\n\n    this.id = id;\n    this.root = root;\n    this._fieldMeta = fieldMeta;\n    this.fullPath = `${this.root}/${this.id}`;\n    this.isShipped = $tw.wiki.getSubTiddler($tm.path.pluginRoot, this.fullPath);\n\n    // finally get the data\n    this._load(data || this.fullPath);\n\n  }\n\n  /**\n   * Load the type's data. Depending on the constructor arguments,\n   * the data source can be a tiddler, a type store\n   *\n   * @private\n   */\n  _load(data) {\n\n    if (!data) {\n\n      return;\n    }\n\n    if (typeof data === 'string') { // assume id or full path\n\n      const isFullPath = utils.startsWith(data, this.root);\n      const tRef = (isFullPath ? data : `${this.root}/${data}`);\n      this._loadFromTiddler(tRef);\n\n    } else if (data instanceof $tw.Tiddler) {\n\n      this._loadFromTiddler(data);\n\n    } else if (typeof data === 'object') { // = type or a data object\n\n      for (let field in this._fieldMeta) {\n        this[field] = data[field];\n      }\n    }\n\n  }\n\n  /**\n   * Retrieve all data from the tiddler provided. If a shadow tiddler\n   * with the same id exists, its data is merged during the load\n   * process.\n   *\n   * @private\n   */\n  _loadFromTiddler(tiddler) {\n\n    const tObj = utils.getTiddler(tiddler);\n\n    if (!tObj) {\n\n      return;\n    }\n\n    const shadowTObj = $tw.wiki.getSubTiddler($tm.path.pluginRoot, this.fullPath) || {};\n\n    // copy object to allow manipulation of the data\n    const rawData = $tw.utils.extend({}, shadowTObj.fields, tObj.fields);\n    // allow parsers to transform the raw field data\n    for (let field in this._fieldMeta) {\n\n      const parser = this._fieldMeta[field].parse;\n      const rawVal = rawData[field];\n\n      this[field] = (parser ? parser.call(this, rawVal) : rawVal);\n    }\n\n  }\n\n  /**\n   * Method to determine whether or not this type exists. A type\n   * exists if a tiddler with the type's id can be found below\n   * the type's root path.\n   *\n   * @return {boolean} True if the type exists, false otherwise.\n   */\n  exists() {\n\n    return utils.tiddlerExists(this.fullPath);\n\n  }\n\n  setStyle(style, isMerge) {\n\n    // preprocessing: try to turn string into json\n    if (typeof style === 'string') {\n\n      style = utils.parseJSON(style);\n\n    }\n\n    // merge or override\n    if (typeof style === 'object') {\n\n      if (isMerge) {\n\n        utils.merge(this.style, style);\n\n      } else {\n\n        this.style = style;\n\n      }\n    }\n\n  }\n\n  /**\n   * Store the type object as tiddler in the wiki. If the `tRef`\n   * property is not provided, the default type path prefix\n   * will be used with the type id appended. Stringifiers provided in\n   * the field meta object (that was passed to the constructor) are\n   * called.\n   *\n   * @param {string} [tRef] - If `tRef` is provided, the type\n   *     data will be written into this tiddler and the id property\n   *     is added as extra field value. Only do this is only for\n   *     dumping purposes!\n   * @param {boolean} [silently=false] do not update the modification date\n   */\n  save(tRef, silently) {\n\n    if (!tRef) {\n\n      tRef = this.fullPath;\n\n    } else if (typeof tRef !== 'string') {\n\n      return;\n\n    }\n\n    // also add an empty text field to guard against\n    // https://github.com/Jermolene/TiddlyWiki5/issues/2025\n    const fields = {\n      title: tRef,\n      text: ''\n    };\n\n    if (!utils.startsWith(tRef, this.root)) {\n\n      // = not the standard path for storing this type!\n      // in this case we add the id to the output.\n      fields.id = this.id;\n\n    }\n\n    // allow parsers to transform the raw field data\n    for (let field in this._fieldMeta) {\n\n      const stringify = this._fieldMeta[field].stringify;\n\n      fields[field] = (stringify ? stringify.call(this, this[field]) : this[field]);\n    }\n\n    if (!this.exists()) { // newly created\n      Object.assign(fields, $tw.wiki.getCreationFields());\n    }\n\n    if (silently !== true) {\n      // add modification date to the output;\n      Object.assign(fields, $tw.wiki.getModificationFields());\n    }\n\n    $tw.wiki.addTiddler(new $tw.Tiddler(fields));\n\n  }\n}\n\n/**\n * A list of fields that are used as data identifiers. Only these\n * listed keys are acknowledged by the load and save functions in\n * this class.\n *\n * This object resembles tw's field modules that are used by\n * `boot.js` to decide how fields are parsed and stringified again.\n */\nMapElementType.fieldMeta = {\n  'description': {},\n  'style': {\n    parse: utils.parseJSON,\n    stringify: JSON.stringify\n  },\n  'modified': {}, // translation handled by TW's core\n  'created': {} // translation handled by TW's core\n};\n\n/*** Exports *******************************************************/\n\nexport default MapElementType;\n"],"sourceRoot":"../../../../../../src/plugins"}